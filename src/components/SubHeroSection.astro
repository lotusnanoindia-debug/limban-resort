---
import { Icon } from 'astro-icon/components'

export interface Props {
  subHero?: {
    aboveHeader?: string;
    title?: string;
    bodyText?: { html: string };
    stats?: Array<{
      svg: string;
      number: string;
      label: string;
    }>;
    image?: { 
      url: string;  // This comes from your API mapping
    };
    imageAltText?: string;
  };
}

const { subHero } = Astro.props;

// ðŸŽ¯ FIXED: Use the correct field from your API
const imageUrl = subHero?.image?.url;  // This is now mapped to optimized local file
const imageAlt = subHero?.imageAltText || "Limban Resort luxury safari experience - award-winning eco-tourism destination in Tadoba National Park Maharashtra";
---

{subHero && (
  <section class="py-24 md:py-32 bg-gray-900" id="about" role="region" aria-labelledby="subhero-title">
    <div class="max-w-7xl mx-auto px-6">
      <div class="grid grid-cols-1 lg:grid-cols-2 gap-16 lg:gap-20 items-center">
        
        <!-- Content section stays the same -->
        <div class="order-2 lg:order-1">
          {subHero.aboveHeader && (
            <div class="inline-block px-4 py-2 bg-amber-400/10 border border-amber-400/30 rounded-full mb-6">
              <span class="text-amber-400 text-xs font-medium tracking-widest uppercase">
                {subHero.aboveHeader}
              </span>
            </div>
          )}
          
          <h2 
            id="subhero-title"
            class="font-serif italic text-3xl md:text-5xl lg:text-6xl text-white mb-8 leading-tight"
          >
            {subHero.title}
          </h2>
          
          {subHero.bodyText?.html && (
            <div
              class="max-w-none mb-8 [&>p]:text-gray-300 [&>p]:leading-relaxed [&>p]:mb-4 [&>p:last-child]:mb-0 [&>strong]:text-white [&>em]:text-amber-400"
              set:html={subHero.bodyText.html}
            />
          )}
          
          {subHero.stats && subHero.stats.length > 0 && (
            <div class="grid grid-cols-3 gap-6 mt-12" role="list" aria-label="Resort statistics">
              {subHero.stats.map((stat, index) => (
                <div
                  key={index}
                  class="group bg-gradient-to-br from-gray-800/40 to-gray-900/60 backdrop-blur-sm border border-gray-700/50 rounded-xl p-6 text-center transition-all duration-500 hover:bg-gray-800/60 hover:border-amber-400/30 hover:-translate-y-2 hover:shadow-xl hover:shadow-black/20"
                  role="listitem"
                >
                  <div class="w-8 h-8 mx-auto mb-4 text-amber-400">
                    <Icon name={stat.svg} class="w-full h-full" />
                  </div>
                  
                  <div class="text-2xl md:text-3xl font-bold text-white mb-2">
                    {stat.number}
                  </div>                  
                  <div class="text-xs md:text-sm text-gray-400 tracking-wide group-hover:text-gray-300 transition-colors duration-300 leading-tight">
                    {stat.label}
                  </div>
                </div>
              ))}
            </div>
          )}
        </div>
        
        <!-- ðŸŽ¯ FIXED: Simplified image section -->
        <div class="order-1 lg:order-2 hidden sm:block">
          <div class="relative aspect-[4/5] bg-gray-800 rounded-2xl overflow-hidden shadow-2xl">
            {imageUrl && (
              <img
                src={imageUrl}
                alt={imageAlt}
                class="w-full h-full object-cover transition-all duration-700 hover:scale-105"
                loading="lazy"
                decoding="async"
              />
            )}
            
            <div class="absolute inset-0 bg-gradient-to-t from-black/20 via-transparent to-transparent pointer-events-none"></div>
          </div>
        </div>
        
      </div>
    </div>
  </section>
)}

<script>
  // Stats animation code stays exactly the same
  if ('IntersectionObserver' in window) {
    const statsObserver = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const statElement = entry.target;
          const numberElement = statElement.querySelector('.text-2xl');
          
          if (numberElement && !numberElement.classList.contains('animated')) {
            numberElement.dataset.number = numberElement.textContent;
            animateNumber(numberElement);
            numberElement.classList.add('animated');
          }
          
          statsObserver.unobserve(entry.target);
        }
      });
    }, {
      threshold: 0.5,
      rootMargin: '0px 0px -50px 0px'
    });

    document.querySelectorAll('[role="listitem"]').forEach(stat => {
      statsObserver.observe(stat);
    });
  }

  function animateNumber(element) {
    const finalValue = element.dataset.number;
    const isNumber = /^\d+$/.test(finalValue);
    
    if (!isNumber) return;
    
    const duration = 2000;
    const startTime = performance.now();
    const targetNumber = parseInt(finalValue);
    
    function updateNumber(currentTime) {
      const elapsed = currentTime - startTime;
      const progress = Math.min(elapsed / duration, 1);
      
      const easeOutQuart = 1 - Math.pow(1 - progress, 4);
      const currentNumber = Math.floor(targetNumber * easeOutQuart);
      
      element.textContent = currentNumber.toLocaleString();
      
      if (progress < 1) {
        requestAnimationFrame(updateNumber);
      } else {
        element.textContent = finalValue;
      }
    }
    
    requestAnimationFrame(updateNumber);
  }
</script>
