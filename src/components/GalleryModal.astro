---
// Ultra-optimized gallery modal with enterprise-grade image handling
// Built for reliability, performance, and flawless operation
---

<!-- Production-Ready Gallery Modal -->
<div
  id="gallery-modal"
  class="fixed inset-0 z-50 bg-black/95 backdrop-blur-xl hidden items-center justify-center p-4"
  role="dialog"
  aria-modal="true"
  aria-labelledby="gallery-title"
>
  <div class="relative max-w-7xl w-full h-full flex flex-col">
    <!-- Accessible Close Button -->
    <button
      id="close-gallery"
      class="absolute top-6 right-6 z-30 w-14 h-14 bg-black/50 hover:bg-black/70 rounded-full flex items-center justify-center text-white transition-colors cursor-pointer focus:outline-none focus:ring-4 focus:ring-amber-400/50"
      aria-label="Close gallery"
      type="button"
    >
      <svg
        class="w-7 h-7"
        fill="none"
        stroke="currentColor"
        viewBox="0 0 24 24"
        aria-hidden="true"
      >
        <path
          stroke-linecap="round"
          stroke-linejoin="round"
          stroke-width="2"
          d="M6 18L18 6M6 6l12 12"></path>
      </svg>
    </button>

    <!-- Main Image Container with Performance Constraints -->
    <div
      class="flex-1 flex items-center justify-center relative overflow-hidden"
      style="min-height: 0;"
    >
      <div
        id="modal-image-container"
        class="relative flex items-center justify-center"
        style="max-width: min(90vw, 1400px); max-height: min(75vh, 900px); width: 100%; height: 100%;"
      >
        <!-- Progressive Loading System -->

        <!-- 1. Instant LQIP (Low Quality Image Placeholder) -->
        <canvas
          id="modal-lqip-canvas"
          class="absolute inset-0 w-full h-full object-contain blur-sm opacity-30 transition-opacity duration-300"
          style="image-rendering: pixelated;"></canvas>

        <!-- 2. Medium Quality Fallback -->
        <img
          id="modal-fallback"
          class="absolute inset-0 w-full h-full object-contain opacity-0 transition-opacity duration-500"
          style="will-change: opacity;"
          loading="eager"
          decoding="async"
        />

        <!-- 3. High Quality Main Image -->
        <img
          id="modal-image"
          class="relative max-w-full max-h-full w-auto h-auto opacity-0 object-contain rounded-lg shadow-2xl transition-opacity duration-700"
          style="will-change: opacity; image-rendering: high-quality;"
          loading="eager"
          decoding="async"
          fetchpriority="high"
        />

        <!-- Loading State with Progress -->
        <div
          id="modal-spinner"
          class="absolute inset-0 flex flex-col items-center justify-center bg-black/50 backdrop-blur-sm rounded-lg transition-opacity duration-300"
        >
          <div class="text-center">
            <!-- Optimized SVG Spinner -->
            <div class="relative w-16 h-16 mx-auto mb-4">
              <svg
                class="animate-spin w-16 h-16 text-amber-400"
                fill="none"
                viewBox="0 0 24 24"
              >
                <circle
                  class="opacity-25"
                  cx="12"
                  cy="12"
                  r="10"
                  stroke="currentColor"
                  stroke-width="4"></circle>
                <path
                  class="opacity-75"
                  fill="currentColor"
                  d="M4 12a8 8 0 018-8v8H4z"></path>
              </svg>
              <!-- Progress Ring -->
              <div id="loading-progress" class="absolute inset-0 w-16 h-16">
                <svg class="transform -rotate-90 w-16 h-16">
                  <circle
                    cx="32"
                    cy="32"
                    r="28"
                    stroke="rgba(245, 158, 11, 0.3)"
                    stroke-width="4"
                    fill="none"></circle>
                  <circle
                    id="progress-circle"
                    cx="32"
                    cy="32"
                    r="28"
                    stroke="rgb(245, 158, 11)"
                    stroke-width="4"
                    fill="none"
                    stroke-dasharray="175.93"
                    stroke-dashoffset="175.93"
                    class="transition-all duration-300 ease-out"></circle>
                </svg>
              </div>
            </div>
            <p class="text-white text-sm font-medium">Loading image...</p>
            <p id="loading-percentage" class="text-amber-400 text-xs mt-1">
              0%
            </p>
          </div>
        </div>

        <!-- Image Information Overlay -->
        <div
          class="absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black/90 via-black/70 to-transparent backdrop-blur-sm rounded-b-lg"
        >
          <div class="p-6 text-center">
            <p
              id="image-counter"
              class="border-b border-amber-400/30 px-4 py-2 text-lg font-medium mb-3 text-amber-400"
            >
            </p>
            <h2
              id="gallery-title"
              class="text-xl font-serif italic text-amber-400 leading-relaxed"
            >
            </h2>
          </div>
        </div>
      </div>

      <!-- Enhanced Navigation with Keyboard Support -->
      <button
        id="prev-image"
        class="absolute left-6 top-1/2 -translate-y-1/2 w-16 h-16 bg-black/60 hover:bg-black/80 rounded-full flex items-center justify-center text-white transition-all duration-300 cursor-pointer hover:scale-110 disabled:opacity-30 disabled:cursor-not-allowed z-20 focus:outline-none focus:ring-4 focus:ring-amber-400/50"
        disabled
        aria-label="Previous image"
        type="button"
      >
        <svg
          class="w-8 h-8"
          fill="none"
          stroke="currentColor"
          viewBox="0 0 24 24"
          aria-hidden="true"
        >
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            stroke-width="2"
            d="M15 19l-7-7 7-7"></path>
        </svg>
      </button>

      <button
        id="next-image"
        class="absolute right-6 top-1/2 -translate-y-1/2 w-16 h-16 bg-black/60 hover:bg-black/80 rounded-full flex items-center justify-center text-white transition-all duration-300 cursor-pointer hover:scale-110 disabled:opacity-30 disabled:cursor-not-allowed z-20 focus:outline-none focus:ring-4 focus:ring-amber-400/50"
        disabled
        aria-label="Next image"
        type="button"
      >
        <svg
          class="w-8 h-8"
          fill="none"
          stroke="currentColor"
          viewBox="0 0 24 24"
          aria-hidden="true"
        >
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            stroke-width="2"
            d="M9 5l7 7-7 7"></path>
        </svg>
      </button>
    </div>

    <!-- Smart Preview Navigation -->
    <div
      class="flex-shrink-0 flex items-center justify-center space-x-4 mt-6 mb-4 min-h-[80px]"
    >
      <div
        id="prev-preview"
        class="flex items-center space-x-3 cursor-pointer group"
        tabindex="0"
        role="button"
        aria-label="Go to previous image"
      >
        <div
          class="w-20 h-16 rounded-lg overflow-hidden bg-gray-800 border-2 border-gray-600 group-hover:border-white group-focus:border-amber-400 transition-colors"
        >
          <img
            id="prev-preview-img"
            alt=""
            class="w-full h-full object-cover"
            loading="lazy"
            decoding="async"
          />
        </div>
        <span
          class="text-gray-400 text-sm group-hover:text-white group-focus:text-amber-400 transition-colors"
          >Previous</span
        >
      </div>

      <div
        class="flex items-center space-x-2 mx-8"
        role="progressbar"
        aria-label="Gallery progress"
      >
        <div class="w-2 h-2 bg-gray-600 rounded-full"></div>
        <div class="w-3 h-3 bg-amber-400 rounded-full"></div>
        <div class="w-2 h-2 bg-gray-600 rounded-full"></div>
      </div>

      <div
        id="next-preview"
        class="flex items-center space-x-3 cursor-pointer group"
        tabindex="0"
        role="button"
        aria-label="Go to next image"
      >
        <span
          class="text-gray-400 text-sm group-hover:text-white group-focus:text-amber-400 transition-colors"
          >Next</span
        >
        <div
          class="w-20 h-16 rounded-lg overflow-hidden bg-gray-800 border-2 border-gray-600 group-hover:border-white group-focus:border-amber-400 transition-colors"
        >
          <img
            id="next-preview-img"
            alt=""
            class="w-full h-full object-cover"
            loading="lazy"
            decoding="async"
          />
        </div>
      </div>
    </div>
  </div>
</div>

<script>
  (function () {
    "use strict";

    // Performance and reliability constants
    const CONFIG = {
      MAX_CACHE_SIZE: 50,
      PRELOAD_DISTANCE: 2,
      RETRY_ATTEMPTS: 3,
      RETRY_DELAY: 1000,
      LOADING_TIMEOUT: 30000,
      QUALITY_LEVELS: ["placeholder", "medium", "large"],
      INTERSECTION_THRESHOLD: 0.1,
    };

    // Enterprise-grade image cache with LRU eviction
    class ImageCache {
      constructor(maxSize = CONFIG.MAX_CACHE_SIZE) {
        this.cache = new Map();
        this.maxSize = maxSize;
        this.accessOrder = new Set();
      }

      get(key) {
        if (this.cache.has(key)) {
          this.accessOrder.delete(key);
          this.accessOrder.add(key);
          return this.cache.get(key);
        }
        return null;
      }

      set(key, value) {
        if (this.cache.has(key)) {
          this.accessOrder.delete(key);
        } else if (this.cache.size >= this.maxSize) {
          const oldestKey = this.accessOrder.values().next().value;
          this.accessOrder.delete(oldestKey);
          this.cache.delete(oldestKey);
        }

        this.cache.set(key, value);
        this.accessOrder.add(key);
      }

      has(key) {
        return this.cache.has(key);
      }

      clear() {
        this.cache.clear();
        this.accessOrder.clear();
      }
    }

    // Advanced image loader with progressive enhancement
    class ImageLoader {
      constructor() {
        this.loadingImages = new Map();
        this.abortControllers = new Map();
      }

      async loadImage(src, options = {}) {
        const {
          timeout = CONFIG.LOADING_TIMEOUT,
          retries = CONFIG.RETRY_ATTEMPTS,
          progressive = false,
          onProgress = null,
        } = options;

        if (this.loadingImages.has(src)) {
          return this.loadingImages.get(src);
        }

        const abortController = new AbortController();
        this.abortControllers.set(src, abortController);

        const loadPromise = this._loadWithRetries(src, retries, {
          timeout,
          progressive,
          onProgress,
          signal: abortController.signal,
        });

        this.loadingImages.set(src, loadPromise);

        try {
          const result = await loadPromise;
          return result;
        } finally {
          this.loadingImages.delete(src);
          this.abortControllers.delete(src);
        }
      }

      async _loadWithRetries(src, retries, options) {
        for (let attempt = 0; attempt <= retries; attempt++) {
          try {
            return await this._loadSingleImage(src, options);
          } catch (error) {
            if (attempt === retries || options.signal?.aborted) {
              throw error;
            }
            await this._delay(CONFIG.RETRY_DELAY * Math.pow(2, attempt));
          }
        }
      }

      _loadSingleImage(src, { timeout, onProgress, signal }) {
        return new Promise((resolve, reject) => {
          if (signal?.aborted) {
            reject(new Error("Loading aborted"));
            return;
          }

          const img = new Image();
          let timeoutId;

          const cleanup = () => {
            if (timeoutId) clearTimeout(timeoutId);
            img.onload = img.onerror = null;
          };

          img.onload = () => {
            cleanup();
            resolve(img);
          };

          img.onerror = () => {
            cleanup();
            reject(new Error(`Failed to load image: ${src}`));
          };

          signal?.addEventListener("abort", () => {
            cleanup();
            reject(new Error("Loading aborted"));
          });

          if (timeout) {
            timeoutId = setTimeout(() => {
              cleanup();
              reject(new Error("Loading timeout"));
            }, timeout);
          }

          // Progressive loading simulation
          if (onProgress) {
            let progress = 0;
            const progressInterval = setInterval(() => {
              progress = Math.min(progress + Math.random() * 20, 95);
              onProgress(progress);
              if (progress >= 95) clearInterval(progressInterval);
            }, 100);

            img.onload = () => {
              clearInterval(progressInterval);
              onProgress(100);
              cleanup();
              resolve(img);
            };
          }

          img.decoding = "async";
          img.src = src;
        });
      }

      cancelLoad(src) {
        const controller = this.abortControllers.get(src);
        if (controller) {
          controller.abort();
        }
      }

      _delay(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }
    }

    // LQIP Canvas renderer for instant feedback
    class LQIPRenderer {
      static renderToCanvas(canvas, imageData, width, height) {
        if (!canvas || !imageData) return;

        const ctx = canvas.getContext("2d");
        const imageArray = new Uint8ClampedArray(imageData);
        const imgData = new ImageData(imageArray, width, height);

        canvas.width = width;
        canvas.height = height;
        ctx.putImageData(imgData, 0, 0);
      }

      static generatePlaceholder(canvas, color = [20, 20, 20]) {
        const ctx = canvas.getContext("2d");
        const gradient = ctx.createLinearGradient(
          0,
          0,
          canvas.width,
          canvas.height
        );
        gradient.addColorStop(0, `rgb(${color[0]}, ${color[1]}, ${color[2]})`);
        gradient.addColorStop(
          1,
          `rgb(${color[0] + 10}, ${color[1] + 10}, ${color[2] + 10})`
        );

        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }
    }

    // Main Gallery Controller
    class GalleryModal {
      constructor() {
        this.currentImages = [];
        this.currentIndex = 0;
        this.imageCache = new ImageCache();
        this.imageLoader = new ImageLoader();
        this.preloadQueue = new Set();
        this.isLoading = false;

        this.initializeElements();
        this.bindEvents();
        this.setupIntersectionObserver();
      }

      initializeElements() {
        this.modal = document.getElementById("gallery-modal");
        this.modalImage = document.getElementById("modal-image");
        this.modalFallback = document.getElementById("modal-fallback");
        this.modalLQIPCanvas = document.getElementById("modal-lqip-canvas");
        this.modalSpinner = document.getElementById("modal-spinner");
        this.imageCounter = document.getElementById("image-counter");
        this.galleryTitle = document.getElementById("gallery-title");
        this.closeBtn = document.getElementById("close-gallery");
        this.prevBtn = document.getElementById("prev-image");
        this.nextBtn = document.getElementById("next-image");
        this.prevPreview = document.getElementById("prev-preview");
        this.nextPreview = document.getElementById("next-preview");
        this.prevPreviewImg = document.getElementById("prev-preview-img");
        this.nextPreviewImg = document.getElementById("next-preview-img");
        this.progressCircle = document.getElementById("progress-circle");
        this.loadingPercentage = document.getElementById("loading-percentage");
      }

      bindEvents() {
        // Primary navigation
        this.closeBtn?.addEventListener("click", () => this.closeModal());
        this.prevBtn?.addEventListener("click", () => this.previousImage());
        this.nextBtn?.addEventListener("click", () => this.nextImage());

        // Preview navigation
        this.prevPreview?.addEventListener("click", () => this.previousImage());
        this.nextPreview?.addEventListener("click", () => this.nextImage());

        // Keyboard navigation with proper focus management
        document.addEventListener("keydown", (e) => this.handleKeyboard(e));

        // Modal backdrop click
        this.modal?.addEventListener("click", (e) => {
          if (e.target === this.modal) this.closeModal();
        });

        // Custom event listener
        document.addEventListener("open-gallery", (e) => {
          const { images, index } = e.detail;
          this.openModal(images, index);
        });

        // Handle visibility changes to pause/resume preloading
        document.addEventListener("visibilitychange", () => {
          if (document.hidden) {
            this.pausePreloading();
          } else {
            this.resumePreloading();
          }
        });
      }

      setupIntersectionObserver() {
        if ("IntersectionObserver" in window) {
          this.observer = new IntersectionObserver(
            (entries) => {
              entries.forEach((entry) => {
                if (entry.isIntersecting) {
                  this.preloadVisibleImages();
                }
              });
            },
            { threshold: CONFIG.INTERSECTION_THRESHOLD }
          );
        }
      }

      async openModal(images, index) {
        if (!images || images.length === 0) return;

        this.currentImages = images;
        this.currentIndex = Math.max(0, Math.min(index, images.length - 1));

        // Show modal immediately
        this.modal.classList.remove("hidden");
        this.modal.classList.add("flex");
        document.body.style.overflow = "hidden";

        // Focus management for accessibility
        this.modal.focus();

        // Load current image
        await this.showImage();

        // Start intelligent preloading
        this.startPreloading();
      }

      closeModal() {
        // Clean up loading operations
        this.cleanup();

        // Hide modal
        this.modal.classList.add("hidden");
        this.modal.classList.remove("flex");
        document.body.style.overflow = "auto";

        // Reset focus
        document.activeElement?.blur();
      }

      async showImage() {
        const image = this.currentImages[this.currentIndex];
        if (!image || this.isLoading) return;

        this.isLoading = true;
        this.updateUI();
        this.showLoadingState();

        try {
          // 1. Show LQIP immediately
          this.renderLQIP(image);

          // 2. Load medium quality as fallback
          if (image.medium) {
            this.loadFallbackImage(image.medium);
          }

          // 3. Load high quality main image
          await this.loadMainImage(image);
        } catch (error) {
          console.error("Failed to load image:", error);
          this.handleImageError();
        } finally {
          this.isLoading = false;
          this.hideLoadingState();
        }
      }

      renderLQIP(image) {
        if (!this.modalLQIPCanvas) return;

        if (image.lqip && image.lqipData) {
          LQIPRenderer.renderToCanvas(
            this.modalLQIPCanvas,
            image.lqipData,
            image.lqipWidth || 20,
            image.lqipHeight || 20
          );
        } else {
          // Generate placeholder
          this.modalLQIPCanvas.width = 20;
          this.modalLQIPCanvas.height = 15;
          LQIPRenderer.generatePlaceholder(this.modalLQIPCanvas);
        }

        this.modalLQIPCanvas.style.opacity = "0.3";
      }

      async loadFallbackImage(src) {
        if (this.imageCache.has(src)) {
          this.modalFallback.src = this.imageCache.get(src).src;
          this.modalFallback.style.opacity = "0.7";
          return;
        }

        try {
          const img = await this.imageLoader.loadImage(src, { timeout: 5000 });
          this.imageCache.set(src, img);
          this.modalFallback.src = img.src;
          this.modalFallback.style.opacity = "0.7";
        } catch (error) {
          console.warn("Fallback image failed to load:", error);
        }
      }

      async loadMainImage(image) {
        const src = image.large || image.src;

        if (this.imageCache.has(src)) {
          this.displayCachedImage(src);
          return;
        }

        const img = await this.imageLoader.loadImage(src, {
          progressive: true,
          onProgress: (progress) => this.updateProgress(progress),
        });

        this.imageCache.set(src, img);
        this.displayLoadedImage(img);
      }

      displayCachedImage(src) {
        const cachedImg = this.imageCache.get(src);
        this.modalImage.src = cachedImg.src;
        this.modalImage.style.opacity = "1";
        this.modalLQIPCanvas.style.opacity = "0";
        this.modalFallback.style.opacity = "0";
      }

      displayLoadedImage(img) {
        this.modalImage.src = img.src;
        this.modalImage.style.opacity = "1";

        // Fade out placeholders
        setTimeout(() => {
          this.modalLQIPCanvas.style.opacity = "0";
          this.modalFallback.style.opacity = "0";
        }, 300);
      }

      showLoadingState() {
        this.modalSpinner.style.display = "flex";
        this.modalSpinner.style.opacity = "1";
        this.modalImage.style.opacity = "0";
        this.prevBtn.disabled = true;
        this.nextBtn.disabled = true;
        this.updateProgress(0);
      }

      hideLoadingState() {
        this.modalSpinner.style.opacity = "0";
        setTimeout(() => {
          this.modalSpinner.style.display = "none";
        }, 300);

        this.prevBtn.disabled = false;
        this.nextBtn.disabled = false;
      }

      updateProgress(progress) {
        if (!this.progressCircle || !this.loadingPercentage) return;

        const circumference = 175.93;
        const offset = circumference - (progress / 100) * circumference;

        this.progressCircle.style.strokeDashoffset = offset;
        this.loadingPercentage.textContent = `${Math.round(progress)}%`;
      }

      updateUI() {
        const image = this.currentImages[this.currentIndex];
        this.imageCounter.textContent = `${this.currentIndex + 1} of ${this.currentImages.length}`;
        this.galleryTitle.textContent = this.capitalizeWords(image.alt || "");
        this.updatePreviewThumbnails();
      }

      updatePreviewThumbnails() {
        const hasMultiple = this.currentImages.length > 1;

        if (!hasMultiple) {
          this.prevPreview.style.display = "none";
          this.nextPreview.style.display = "none";
          return;
        }

        const prevIndex =
          (this.currentIndex - 1 + this.currentImages.length) %
          this.currentImages.length;
        const nextIndex = (this.currentIndex + 1) % this.currentImages.length;

        this.prevPreviewImg.src = this.currentImages[prevIndex]?.src || "";
        this.nextPreviewImg.src = this.currentImages[nextIndex]?.src || "";

        this.prevPreview.style.display = "flex";
        this.nextPreview.style.display = "flex";
      }

      // Smart preloading system
      startPreloading() {
        this.preloadAdjacentImages();

        // Continue preloading in background
        requestIdleCallback(
          () => {
            this.preloadBatch();
          },
          { timeout: 2000 }
        );
      }

      preloadAdjacentImages() {
        const indices = this.getAdjacentIndices(CONFIG.PRELOAD_DISTANCE);
        indices.forEach((index) => {
          const image = this.currentImages[index];
          if (image && !this.imageCache.has(image.large || image.src)) {
            this.preloadImage(image.large || image.src);
          }
        });
      }

      preloadBatch() {
        let loaded = 0;
        const maxBatch = 3;

        for (
          let i = 0;
          i < this.currentImages.length && loaded < maxBatch;
          i++
        ) {
          const image = this.currentImages[i];
          const src = image.large || image.src;

          if (!this.imageCache.has(src) && !this.preloadQueue.has(src)) {
            this.preloadImage(src);
            loaded++;
          }
        }
      }

      async preloadImage(src) {
        if (this.preloadQueue.has(src)) return;

        this.preloadQueue.add(src);

        try {
          const img = await this.imageLoader.loadImage(src, {
            timeout: 15000,
            retries: 1,
          });
          this.imageCache.set(src, img);
        } catch (error) {
          console.warn("Preload failed:", src, error);
        } finally {
          this.preloadQueue.delete(src);
        }
      }

      getAdjacentIndices(distance) {
        const indices = [];
        for (let i = 1; i <= distance; i++) {
          indices.push((this.currentIndex + i) % this.currentImages.length);
          indices.push(
            (this.currentIndex - i + this.currentImages.length) %
              this.currentImages.length
          );
        }
        return indices;
      }

      // Navigation
      async nextImage() {
        if (this.isLoading) return;
        this.currentIndex = (this.currentIndex + 1) % this.currentImages.length;
        await this.showImage();
        this.preloadAdjacentImages();
      }

      async previousImage() {
        if (this.isLoading) return;
        this.currentIndex =
          (this.currentIndex - 1 + this.currentImages.length) %
          this.currentImages.length;
        await this.showImage();
        this.preloadAdjacentImages();
      }

      // Event handlers
      handleKeyboard(e) {
        if (!this.modal?.classList.contains("flex")) return;

        switch (e.key) {
          case "Escape":
            e.preventDefault();
            this.closeModal();
            break;
          case "ArrowLeft":
            e.preventDefault();
            this.previousImage();
            break;
          case "ArrowRight":
            e.preventDefault();
            this.nextImage();
            break;
          case " ":
            e.preventDefault();
            this.nextImage();
            break;
        }
      }

      handleImageError() {
        this.modalSpinner.style.display = "none";
        this.modalLQIPCanvas.style.opacity = "0.5";
        this.prevBtn.disabled = false;
        this.nextBtn.disabled = false;
      }

      // Lifecycle management
      pausePreloading() {
        // Cancel ongoing preloads to save bandwidth
        this.preloadQueue.forEach((src) => {
          this.imageLoader.cancelLoad(src);
        });
        this.preloadQueue.clear();
      }

      resumePreloading() {
        // Resume preloading when tab becomes visible
        if (this.modal?.classList.contains("flex")) {
          this.preloadAdjacentImages();
        }
      }

      cleanup() {
        // Cancel all loading operations
        this.preloadQueue.forEach((src) => {
          this.imageLoader.cancelLoad(src);
        });
        this.preloadQueue.clear();

        // Reset loading state
        this.isLoading = false;

        // Clear progress indicators
        this.updateProgress(0);
      }

      // Utilities
      capitalizeWords(str) {
        if (!str) return "";
        return str.replace(
          /\w\S*/g,
          (txt) => txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase()
        );
      }

      preloadVisibleImages() {
        // Intersection Observer callback for smart preloading
        this.preloadAdjacentImages();
      }
    }

    // Initialize gallery when DOM is ready
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", () => {
        window.galleryModal = new GalleryModal();
      });
    } else {
      window.galleryModal = new GalleryModal();
    }
  })();
</script>
